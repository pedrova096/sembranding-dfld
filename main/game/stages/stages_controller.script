local Tiles = {
	Seedable = 2,
}

local Urls = {
	Stage = "#stage",
}

local TILE_SIZE = 48
local TILE_PADDING_TOP = 16

---Returns a table of all seedable tile positions {x, y} in world coordinates
---@return table[] Array of {x, y, tile_x, tile_y} positions
local function get_seedable_tiles()
	local seedable_positions = {}
	local layer = "tiles"

	-- Get tilemap bounds
	local x, y, w, h = tilemap.get_bounds(Urls.Stage)

	-- Iterate through all tiles
	for row = y, y + h - 1 do
		for col = x, x + w - 1 do
			local tile = tilemap.get_tile(Urls.Stage, layer, col, row)

			if tile == Tiles.Seedable then
				-- Store both tile coordinates and world position
				table.insert(seedable_positions, {
					tile_x = col,
					tile_y = row,
					x = (col - 0.5) * TILE_SIZE,
					y = row * TILE_SIZE - TILE_PADDING_TOP,
				})
			end
		end
	end

	return seedable_positions
end

function init(self)
	self.seedable_tiles = get_seedable_tiles()

	pprint(self.seedable_tiles)
end

function update(self, dt)
	for _, tile in ipairs(self.seedable_tiles) do
		-- draw a crosshair at the tile position
		msg.post("@render:", "draw_line", {
			start_point = vmath.vector3(tile.x - 10, tile.y, 0),
			end_point = vmath.vector3(tile.x + 10, tile.y, 0),
			color = vmath.vector4(1, 0, 0, 1)
		})
		msg.post("@render:", "draw_line", {
			start_point = vmath.vector3(tile.x, tile.y - 10, 0),
			end_point = vmath.vector3(tile.x, tile.y + 10, 0),
			color = vmath.vector4(1, 0, 0, 1)
		})
	end
end

function on_message(self, message_id, message, sender)
end
